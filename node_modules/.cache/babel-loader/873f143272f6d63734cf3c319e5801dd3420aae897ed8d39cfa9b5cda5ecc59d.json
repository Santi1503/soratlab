{"ast":null,"code":"export const algorithms = [{\n  id: 'bubble-sort',\n  name: 'Bubble Sort',\n  description: 'Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.',\n  complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void bubbleSort(int[] arr) {\n  int n = arr.length;\n  for (int i = 0; i < n-1; i++) {\n    for (int j = 0; j < n-i-1; j++) {\n      if (arr[j] > arr[j+1]) {\n        int temp = arr[j];\n        arr[j] = arr[j+1];\n        arr[j+1] = temp;\n      }\n    }\n  }\n}`,\n    python: `def bubble_sort(arr):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] = arr[j+1], arr[j]`,\n    php: `function bubbleSort(&$arr) {\n  $n = count($arr);\n  for ($i = 0; $i < $n-1; $i++) {\n    for ($j = 0; $j < $n-$i-1; $j++) {\n      if ($arr[$j] > $arr[$j+1]) {\n        $temp = $arr[$j];\n        $arr[$j] = $arr[$j+1];\n        $arr[$j+1] = $temp;\n      }\n    }\n  }\n}`,\n    javascript: `function bubbleSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n-1; i++) {\n    for (let j = 0; j < n-i-1; j++) {\n      if (arr[j] > arr[j+1]) {\n        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];\n      }\n    }\n  }\n}`,\n    csharp: `public void BubbleSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = 0; i < n-1; i++) {\n    for (int j = 0; j < n-i-1; j++) {\n      if (arr[j] > arr[j+1]) {\n        int temp = arr[j];\n        arr[j] = arr[j+1];\n        arr[j+1] = temp;\n      }\n    }\n  }\n}`\n  }\n}, {\n  id: 'quick-sort',\n  name: 'Quick Sort',\n  description: 'A divide and conquer algorithm that works by selecting a pivot element and partitioning the array around the pivot.',\n  complexity: 'Best: O(n log n), Average: O(n log n), Worst: O(n²)',\n  code: {\n    java: `public void quickSort(int[] arr, int low, int high) {\n  if (low < high) {\n    int pi = partition(arr, low, high);\n    quickSort(arr, low, pi-1);\n    quickSort(arr, pi+1, high);\n  }\n}\n\nprivate int partition(int[] arr, int low, int high) {\n  int pivot = arr[high];\n  int i = (low-1);\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      int temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n  int temp = arr[i+1];\n  arr[i+1] = arr[high];\n  arr[high] = temp;\n  return i+1;\n}`,\n    python: `def quick_sort(arr, low, high):\n  if low < high:\n    pi = partition(arr, low, high)\n    quick_sort(arr, low, pi-1)\n    quick_sort(arr, pi+1, high)\n\ndef partition(arr, low, high):\n  pivot = arr[high]\n  i = low - 1\n  for j in range(low, high):\n    if arr[j] < pivot:\n      i += 1\n      arr[i], arr[j] = arr[j], arr[i]\n  arr[i+1], arr[high] = arr[high], arr[i+1]\n  return i+1`,\n    php: `function quickSort($arr, $low, $high) {\n  if ($low < $high) {\n    $pi = partition($arr, $low, $high);\n    quickSort($arr, $low, $pi-1);\n    quickSort($arr, $pi+1, $high);\n  }\n  return $arr;\n}\n\nfunction partition($arr, $low, $high) {\n  $pivot = $arr[$high];\n  $i = $low - 1;\n  for ($j = $low; $j < $high; $j++) {\n    if ($arr[$j] < $pivot) {\n      $i++;\n      $temp = $arr[$i];\n      $arr[$i] = $arr[$j];\n      $arr[$j] = $temp;\n    }\n  }\n  $temp = $arr[$i+1];\n  $arr[$i+1] = $arr[$high];\n  $arr[$high] = $temp;\n  return $i+1;\n}`,\n    javascript: `function quickSort(arr, low, high) {\n  if (low < high) {\n    const pi = partition(arr, low, high);\n    quickSort(arr, low, pi-1);\n    quickSort(arr, pi+1, high);\n  }\n}\n\nfunction partition(arr, low, high) {\n  const pivot = arr[high];\n  let i = low - 1;\n  for (let j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i+1], arr[high]] = [arr[high], arr[i+1]];\n  return i+1;\n}`,\n    csharp: `public void QuickSort(int[] arr, int low, int high) {\n  if (low < high) {\n    int pi = Partition(arr, low, high);\n    QuickSort(arr, low, pi-1);\n    QuickSort(arr, pi+1, high);\n  }\n}\n\nprivate int Partition(int[] arr, int low, int high) {\n  int pivot = arr[high];\n  int i = low - 1;\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      int temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n  int temp = arr[i+1];\n  arr[i+1] = arr[high];\n  arr[high] = temp;\n  return i+1;\n}`\n  }\n}, {\n  id: 'merge-sort',\n  name: 'Merge Sort',\n  description: 'A divide and conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.',\n  complexity: 'Best: O(n log n), Average: O(n log n), Worst: O(n log n)',\n  code: {\n    java: `public void mergeSort(int[] arr, int left, int right) {\n  if (left < right) {\n    int middle = (left + right) / 2;\n    mergeSort(arr, left, middle);\n    mergeSort(arr, middle + 1, right);\n    merge(arr, left, middle, right);\n  }\n}\n\nprivate void merge(int[] arr, int left, int middle, int right) {\n  int n1 = middle - left + 1;\n  int n2 = right - middle;\n  int[] L = new int[n1];\n  int[] R = new int[n2];\n  \n  for (int i = 0; i < n1; i++)\n    L[i] = arr[left + i];\n  for (int j = 0; j < n2; j++)\n    R[j] = arr[middle + 1 + j];\n    \n  int i = 0, j = 0, k = left;\n  while (i < n1 && j < n2) {\n    if (L[i] <= R[j]) {\n      arr[k] = L[i];\n      i++;\n    } else {\n      arr[k] = R[j];\n      j++;\n    }\n    k++;\n  }\n  \n  while (i < n1) {\n    arr[k] = L[i];\n    i++;\n    k++;\n  }\n  \n  while (j < n2) {\n    arr[k] = R[j];\n    j++;\n    k++;\n  }\n}`,\n    python: `def merge_sort(arr):\n  if len(arr) > 1:\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    merge_sort(left)\n    merge_sort(right)\n    \n    i = j = k = 0\n    while i < len(left) and j < len(right):\n      if left[i] < right[j]:\n        arr[k] = left[i]\n        i += 1\n      else:\n        arr[k] = right[j]\n        j += 1\n      k += 1\n      \n    while i < len(left):\n      arr[k] = left[i]\n      i += 1\n      k += 1\n      \n    while j < len(right):\n      arr[k] = right[j]\n      j += 1\n      k += 1`,\n    php: `function mergeSort($arr) {\n  if (count($arr) <= 1) return $arr;\n  \n  $mid = floor(count($arr) / 2);\n  $left = array_slice($arr, 0, $mid);\n  $right = array_slice($arr, $mid);\n  \n  $left = mergeSort($left);\n  $right = mergeSort($right);\n  \n  return merge($left, $right);\n}\n\nfunction merge($left, $right) {\n  $result = [];\n  $i = $j = 0;\n  \n  while ($i < count($left) && $j < count($right)) {\n    if ($left[$i] <= $right[$j]) {\n      $result[] = $left[$i];\n      $i++;\n    } else {\n      $result[] = $right[$j];\n      $j++;\n    }\n  }\n  \n  while ($i < count($left)) {\n    $result[] = $left[$i];\n    $i++;\n  }\n  \n  while ($j < count($right)) {\n    $result[] = $right[$j];\n    $j++;\n  }\n  \n  return $result;\n}`,\n    javascript: `function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n  \n  return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let i = 0, j = 0;\n  \n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i]);\n      i++;\n    } else {\n      result.push(right[j]);\n      j++;\n    }\n  }\n  \n  return result.concat(left.slice(i)).concat(right.slice(j));\n}`,\n    csharp: `public void MergeSort(int[] arr, int left, int right) {\n  if (left < right) {\n    int middle = (left + right) / 2;\n    MergeSort(arr, left, middle);\n    MergeSort(arr, middle + 1, right);\n    Merge(arr, left, middle, right);\n  }\n}\n\nprivate void Merge(int[] arr, int left, int middle, int right) {\n  int n1 = middle - left + 1;\n  int n2 = right - middle;\n  int[] L = new int[n1];\n  int[] R = new int[n2];\n  \n  for (int i = 0; i < n1; i++)\n    L[i] = arr[left + i];\n  for (int j = 0; j < n2; j++)\n    R[j] = arr[middle + 1 + j];\n    \n  int i = 0, j = 0, k = left;\n  while (i < n1 && j < n2) {\n    if (L[i] <= R[j]) {\n      arr[k] = L[i];\n      i++;\n    } else {\n      arr[k] = R[j];\n      j++;\n    }\n    k++;\n  }\n  \n  while (i < n1) {\n    arr[k] = L[i];\n    i++;\n    k++;\n  }\n  \n  while (j < n2) {\n    arr[k] = R[j];\n    j++;\n    k++;\n  }\n}`\n  }\n}, {\n  id: 'insertion-sort',\n  name: 'Insertion Sort',\n  description: 'A simple sorting algorithm that builds the final sorted array one item at a time.',\n  complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void insertionSort(int[] arr) {\n  int n = arr.length;\n  for (int i = 1; i < n; i++) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n}`,\n    python: `def insertion_sort(arr):\n  for i in range(1, len(arr)):\n    key = arr[i]\n    j = i - 1\n    while j >= 0 and arr[j] > key:\n      arr[j + 1] = arr[j]\n      j -= 1\n    arr[j + 1] = key`,\n    php: `function insertionSort($arr) {\n  $n = count($arr);\n  for ($i = 1; $i < $n; $i++) {\n    $key = $arr[$i];\n    $j = $i - 1;\n    while ($j >= 0 && $arr[$j] > $key) {\n      $arr[$j + 1] = $arr[$j];\n      $j = $j - 1;\n    }\n    $arr[$j + 1] = $key;\n  }\n  return $arr;\n}`,\n    javascript: `function insertionSort(arr) {\n  const n = arr.length;\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n}`,\n    csharp: `public void InsertionSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = 1; i < n; i++) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n}`\n  }\n}, {\n  id: 'selection-sort',\n  name: 'Selection Sort',\n  description: 'A sorting algorithm that repeatedly finds the minimum element from the unsorted part and puts it at the beginning.',\n  complexity: 'Best: O(n²), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void selectionSort(int[] arr) {\n  int n = arr.length;\n  for (int i = 0; i < n-1; i++) {\n    int min_idx = i;\n    for (int j = i+1; j < n; j++) {\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n    int temp = arr[min_idx];\n    arr[min_idx] = arr[i];\n    arr[i] = temp;\n  }\n}`,\n    python: `def selection_sort(arr):\n  n = len(arr)\n  for i in range(n):\n    min_idx = i\n    for j in range(i+1, n):\n      if arr[j] < arr[min_idx]:\n        min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]`,\n    php: `function selectionSort($arr) {\n  $n = count($arr);\n  for ($i = 0; $i < $n-1; $i++) {\n    $min_idx = $i;\n    for ($j = $i+1; $j < $n; $j++) {\n      if ($arr[$j] < $arr[$min_idx]) {\n        $min_idx = $j;\n      }\n    }\n    $temp = $arr[$min_idx];\n    $arr[$min_idx] = $arr[$i];\n    $arr[$i] = $temp;\n  }\n  return $arr;\n}`,\n    javascript: `function selectionSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n-1; i++) {\n    let min_idx = i;\n    for (let j = i+1; j < n; j++) {\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n    [arr[i], arr[min_idx]] = [arr[min_idx], arr[i]];\n  }\n}`,\n    csharp: `public void SelectionSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = 0; i < n-1; i++) {\n    int min_idx = i;\n    for (int j = i+1; j < n; j++) {\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n    int temp = arr[min_idx];\n    arr[min_idx] = arr[i];\n    arr[i] = temp;\n  }\n}`\n  }\n}, {\n  id: 'heap-sort',\n  name: 'Heap Sort',\n  description: 'A comparison-based sorting algorithm that uses a binary heap data structure to sort elements.',\n  complexity: 'Best: O(n log n), Average: O(n log n), Worst: O(n log n)',\n  code: {\n    java: `public void heapSort(int[] arr) {\n  int n = arr.length;\n  for (int i = n / 2 - 1; i >= 0; i--)\n    heapify(arr, n, i);\n  for (int i = n - 1; i > 0; i--) {\n    int temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    heapify(arr, i, 0);\n  }\n}\n\nprivate void heapify(int[] arr, int n, int i) {\n  int largest = i;\n  int l = 2 * i + 1;\n  int r = 2 * i + 2;\n  if (l < n && arr[l] > arr[largest])\n    largest = l;\n  if (r < n && arr[r] > arr[largest])\n    largest = r;\n  if (largest != i) {\n    int swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap;\n    heapify(arr, n, largest);\n  }\n}`,\n    python: `def heapify(arr, n, i):\n  largest = i\n  l = 2 * i + 1\n  r = 2 * i + 2\n  if l < n and arr[i] < arr[l]:\n    largest = l\n  if r < n and arr[largest] < arr[r]:\n    largest = r\n  if largest != i:\n    arr[i], arr[largest] = arr[largest], arr[i]\n    heapify(arr, n, largest)\n\ndef heap_sort(arr):\n  n = len(arr)\n  for i in range(n//2 - 1, -1, -1):\n    heapify(arr, n, i)\n  for i in range(n-1, 0, -1):\n    arr[i], arr[0] = arr[0], arr[i]\n    heapify(arr, i, 0)`,\n    php: `function heapify(&$arr, $n, $i) {\n  $largest = $i;\n  $l = 2 * $i + 1;\n  $r = 2 * $i + 2;\n  if ($l < $n && $arr[$l] > $arr[$largest])\n    $largest = $l;\n  if ($r < $n && $arr[$r] > $arr[$largest])\n    $largest = $r;\n  if ($largest != $i) {\n    $swap = $arr[$i];\n    $arr[$i] = $arr[$largest];\n    $arr[$largest] = $swap;\n    heapify($arr, $n, $largest);\n  }\n}\n\nfunction heapSort($arr) {\n  $n = count($arr);\n  for ($i = $n / 2 - 1; $i >= 0; $i--)\n    heapify($arr, $n, $i);\n  for ($i = $n - 1; $i > 0; $i--) {\n    $temp = $arr[0];\n    $arr[0] = $arr[$i];\n    $arr[$i] = $temp;\n    heapify($arr, $i, 0);\n  }\n  return $arr;\n}`,\n    javascript: `function heapify(arr, n, i) {\n  let largest = i;\n  let l = 2 * i + 1;\n  let r = 2 * i + 2;\n  if (l < n && arr[l] > arr[largest])\n    largest = l;\n  if (r < n && arr[r] > arr[largest])\n    largest = r;\n  if (largest != i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n\nfunction heapSort(arr) {\n  const n = arr.length;\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--)\n    heapify(arr, n, i);\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n}`,\n    csharp: `public void HeapSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = n / 2 - 1; i >= 0; i--)\n    Heapify(arr, n, i);\n  for (int i = n - 1; i > 0; i--) {\n    int temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    Heapify(arr, i, 0);\n  }\n}\n\nprivate void Heapify(int[] arr, int n, int i) {\n  int largest = i;\n  int l = 2 * i + 1;\n  int r = 2 * i + 2;\n  if (l < n && arr[l] > arr[largest])\n    largest = l;\n  if (r < n && arr[r] > arr[largest])\n    largest = r;\n  if (largest != i) {\n    int swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap;\n    Heapify(arr, n, largest);\n  }\n}`\n  }\n}, {\n  id: 'shell-sort',\n  name: 'Shell Sort',\n  description: 'An optimization of insertion sort that allows the exchange of items that are far apart.',\n  complexity: 'Best: O(n log n), Average: O(n log² n), Worst: O(n²)',\n  code: {\n    java: `public void shellSort(int[] arr) {\n  int n = arr.length;\n  for (int gap = n/2; gap > 0; gap /= 2) {\n    for (int i = gap; i < n; i++) {\n      int temp = arr[i];\n      int j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n        arr[j] = arr[j - gap];\n      arr[j] = temp;\n    }\n  }\n}`,\n    python: `def shell_sort(arr):\n  n = len(arr)\n  gap = n // 2\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n    gap //= 2`,\n    php: `function shellSort($arr) {\n  $n = count($arr);\n  for ($gap = $n/2; $gap > 0; $gap /= 2) {\n    for ($i = $gap; $i < $n; $i++) {\n      $temp = $arr[$i];\n      for ($j = $i; $j >= $gap && $arr[$j - $gap] > $temp; $j -= $gap)\n        $arr[$j] = $arr[$j - $gap];\n      $arr[$j] = $temp;\n    }\n  }\n  return $arr;\n}`,\n    javascript: `function shellSort(arr) {\n  const n = arr.length;\n  for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {\n    for (let i = gap; i < n; i++) {\n      let temp = arr[i];\n      let j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n        arr[j] = arr[j - gap];\n      arr[j] = temp;\n    }\n  }\n}`,\n    csharp: `public void ShellSort(int[] arr) {\n  int n = arr.Length;\n  for (int gap = n/2; gap > 0; gap /= 2) {\n    for (int i = gap; i < n; i++) {\n      int temp = arr[i];\n      int j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n        arr[j] = arr[j - gap];\n      arr[j] = temp;\n    }\n  }\n}`\n  }\n}, {\n  id: 'counting-sort',\n  name: 'Counting Sort',\n  description: 'A sorting algorithm that works by counting the number of objects having distinct key values.',\n  complexity: 'Best: O(n + k), Average: O(n + k), Worst: O(n + k)',\n  code: {\n    java: `public void countingSort(int[] arr) {\n  int max = Arrays.stream(arr).max().getAsInt();\n  int min = Arrays.stream(arr).min().getAsInt();\n  int range = max - min + 1;\n  int[] count = new int[range];\n  int[] output = new int[arr.length];\n  \n  for (int i = 0; i < arr.length; i++)\n    count[arr[i] - min]++;\n  \n  for (int i = 1; i < count.length; i++)\n    count[i] += count[i - 1];\n  \n  for (int i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n  \n  System.arraycopy(output, 0, arr, 0, arr.length);\n}`,\n    python: `def counting_sort(arr):\n  max_val = max(arr)\n  min_val = min(arr)\n  range_val = max_val - min_val + 1\n  count = [0] * range_val\n  output = [0] * len(arr)\n  \n  for i in range(len(arr)):\n    count[arr[i] - min_val] += 1\n    \n  for i in range(1, len(count)):\n    count[i] += count[i - 1]\n    \n  for i in range(len(arr) - 1, -1, -1):\n    output[count[arr[i] - min_val] - 1] = arr[i]\n    count[arr[i] - min_val] -= 1\n    \n  for i in range(len(arr)):\n    arr[i] = output[i]`,\n    php: `function countingSort($arr) {\n  $max = max($arr);\n  $min = min($arr);\n  $range = $max - $min + 1;\n  $count = array_fill(0, $range, 0);\n  $output = array_fill(0, count($arr), 0);\n  \n  for ($i = 0; $i < count($arr); $i++)\n    $count[$arr[$i] - $min]++;\n    \n  for ($i = 1; $i < count($count); $i++)\n    $count[$i] += $count[$i - 1];\n    \n  for ($i = count($arr) - 1; $i >= 0; $i--) {\n    $output[$count[$arr[$i] - $min] - 1] = $arr[$i];\n    $count[$arr[$i] - $min]--;\n  }\n  \n  for ($i = 0; $i < count($arr); $i++)\n    $arr[$i] = $output[$i];\n    \n  return $arr;\n}`,\n    javascript: `function countingSort(arr) {\n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const range = max - min + 1;\n  const count = new Array(range).fill(0);\n  const output = new Array(arr.length).fill(0);\n  \n  for (let i = 0; i < arr.length; i++)\n    count[arr[i] - min]++;\n    \n  for (let i = 1; i < count.length; i++)\n    count[i] += count[i - 1];\n    \n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n  \n  for (let i = 0; i < arr.length; i++)\n    arr[i] = output[i];\n}`,\n    csharp: `public void CountingSort(int[] arr) {\n  int max = arr.Max();\n  int min = arr.Min();\n  int range = max - min + 1;\n  int[] count = new int[range];\n  int[] output = new int[arr.Length];\n  \n  for (int i = 0; i < arr.Length; i++)\n    count[arr[i] - min]++;\n    \n  for (int i = 1; i < count.Length; i++)\n    count[i] += count[i - 1];\n    \n  for (int i = arr.Length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n  \n  Array.Copy(output, arr, arr.Length);\n}`\n  }\n}, {\n  id: 'radix-sort',\n  name: 'Radix Sort',\n  description: 'A non-comparative sorting algorithm that sorts data with integer keys by grouping keys by the individual digits.',\n  complexity: 'Best: O(nk), Average: O(nk), Worst: O(nk)',\n  code: {\n    java: `public void radixSort(int[] arr) {\n  int max = Arrays.stream(arr).max().getAsInt();\n  for (int exp = 1; max/exp > 0; exp *= 10)\n    countSort(arr, exp);\n}\n\nprivate void countSort(int[] arr, int exp) {\n  int[] output = new int[arr.length];\n  int[] count = new int[10];\n  \n  for (int i = 0; i < arr.length; i++)\n    count[(arr[i]/exp) % 10]++;\n    \n  for (int i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n    \n  for (int i = arr.length - 1; i >= 0; i--) {\n    output[count[(arr[i]/exp) % 10] - 1] = arr[i];\n    count[(arr[i]/exp) % 10]--;\n  }\n  \n  System.arraycopy(output, 0, arr, 0, arr.length);\n}`,\n    python: `def counting_sort(arr, exp):\n  n = len(arr)\n  output = [0] * n\n  count = [0] * 10\n  \n  for i in range(n):\n    index = arr[i] // exp\n    count[index % 10] += 1\n    \n  for i in range(1, 10):\n    count[i] += count[i - 1]\n    \n  i = n - 1\n  while i >= 0:\n    index = arr[i] // exp\n    output[count[index % 10] - 1] = arr[i]\n    count[index % 10] -= 1\n    i -= 1\n    \n  for i in range(n):\n    arr[i] = output[i]\n\ndef radix_sort(arr):\n  max_val = max(arr)\n  exp = 1\n  while max_val // exp > 0:\n    counting_sort(arr, exp)\n    exp *= 10`,\n    php: `function countSort(&$arr, $exp) {\n  $n = count($arr);\n  $output = array_fill(0, $n, 0);\n  $count = array_fill(0, 10, 0);\n  \n  for ($i = 0; $i < $n; $i++)\n    $count[($arr[$i]/$exp) % 10]++;\n    \n  for ($i = 1; $i < 10; $i++)\n    $count[$i] += $count[$i - 1];\n    \n  for ($i = $n - 1; $i >= 0; $i--) {\n    $output[$count[($arr[$i]/$exp) % 10] - 1] = $arr[$i];\n    $count[($arr[$i]/$exp) % 10]--;\n  }\n  \n  for ($i = 0; $i < $n; $i++)\n    $arr[$i] = $output[$i];\n}\n\nfunction radixSort($arr) {\n  $max = max($arr);\n  for ($exp = 1; $max/$exp > 0; $exp *= 10)\n    countSort($arr, $exp);\n  return $arr;\n}`,\n    javascript: `function countSort(arr, exp) {\n  const n = arr.length;\n  const output = new Array(n).fill(0);\n  const count = new Array(10).fill(0);\n  \n  for (let i = 0; i < n; i++)\n    count[Math.floor(arr[i]/exp) % 10]++;\n    \n  for (let i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n    \n  for (let i = n - 1; i >= 0; i--) {\n    output[count[Math.floor(arr[i]/exp) % 10] - 1] = arr[i];\n    count[Math.floor(arr[i]/exp) % 10]--;\n  }\n  \n  for (let i = 0; i < n; i++)\n    arr[i] = output[i];\n}\n\nfunction radixSort(arr) {\n  const max = Math.max(...arr);\n  for (let exp = 1; Math.floor(max/exp) > 0; exp *= 10)\n    countSort(arr, exp);\n}`,\n    csharp: `private void CountSort(int[] arr, int exp) {\n  int n = arr.Length;\n  int[] output = new int[n];\n  int[] count = new int[10];\n  \n  for (int i = 0; i < n; i++)\n    count[(arr[i]/exp) % 10]++;\n    \n  for (int i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n    \n  for (int i = n - 1; i >= 0; i--) {\n    output[count[(arr[i]/exp) % 10] - 1] = arr[i];\n    count[(arr[i]/exp) % 10]--;\n  }\n  \n  Array.Copy(output, arr, n);\n}\n\npublic void RadixSort(int[] arr) {\n  int max = arr.Max();\n  for (int exp = 1; max/exp > 0; exp *= 10)\n    CountSort(arr, exp);\n}`\n  }\n}, {\n  id: 'bucket-sort',\n  name: 'Bucket Sort',\n  description: 'A sorting algorithm that works by distributing the elements of an array into a number of buckets.',\n  complexity: 'Best: O(n + k), Average: O(n + n²/k), Worst: O(n²)',\n  code: {\n    java: `public void bucketSort(float[] arr) {\n  int n = arr.length;\n  ArrayList<Float>[] buckets = new ArrayList[n];\n  \n  for (int i = 0; i < n; i++)\n    buckets[i] = new ArrayList<>();\n    \n  for (int i = 0; i < n; i++) {\n    int bucketIndex = (int) (n * arr[i]);\n    buckets[bucketIndex].add(arr[i]);\n  }\n  \n  for (int i = 0; i < n; i++)\n    Collections.sort(buckets[i]);\n    \n  int index = 0;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < buckets[i].size(); j++)\n      arr[index++] = buckets[i].get(j);\n}`,\n    python: `def bucket_sort(arr):\n  n = len(arr)\n  buckets = [[] for _ in range(n)]\n  \n  for num in arr:\n    bucket_index = int(n * num)\n    buckets[bucket_index].append(num)\n    \n  for bucket in buckets:\n    bucket.sort()\n    \n  index = 0\n  for bucket in buckets:\n    for num in bucket:\n      arr[index] = num\n      index += 1`,\n    php: `function bucketSort($arr) {\n  $n = count($arr);\n  $buckets = array_fill(0, $n, array());\n  \n  for ($i = 0; $i < $n; $i++) {\n    $bucketIndex = (int)($n * $arr[$i]);\n    $buckets[$bucketIndex][] = $arr[$i];\n  }\n  \n  for ($i = 0; $i < $n; $i++)\n    sort($buckets[$i]);\n    \n  $index = 0;\n  for ($i = 0; $i < $n; $i++)\n    for ($j = 0; $j < count($buckets[$i]); $j++)\n      $arr[$index++] = $buckets[$i][$j];\n      \n  return $arr;\n}`,\n    javascript: `function bucketSort(arr) {\n  const n = arr.length;\n  const buckets = Array.from({ length: n }, () => []);\n  \n  for (const num of arr) {\n    const bucketIndex = Math.floor(n * num);\n    buckets[bucketIndex].push(num);\n  }\n  \n  for (const bucket of buckets)\n    bucket.sort((a, b) => a - b);\n    \n  let index = 0;\n  for (const bucket of buckets)\n    for (const num of bucket)\n      arr[index++] = num;\n}`,\n    csharp: `public void BucketSort(float[] arr) {\n  int n = arr.Length;\n  List<float>[] buckets = new List<float>[n];\n  \n  for (int i = 0; i < n; i++)\n    buckets[i] = new List<float>();\n    \n  for (int i = 0; i < n; i++) {\n    int bucketIndex = (int)(n * arr[i]);\n    buckets[bucketIndex].Add(arr[i]);\n  }\n  \n  for (int i = 0; i < n; i++)\n    buckets[i].Sort();\n    \n  int index = 0;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < buckets[i].Count; j++)\n      arr[index++] = buckets[i][j];\n}`\n  }\n}, {\n  id: 'cocktail-sort',\n  name: 'Cocktail Sort',\n  description: 'A variation of bubble sort that sorts in both directions alternatively.',\n  complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void cocktailSort(int[] arr) {\n  boolean swapped = true;\n  int start = 0;\n  int end = arr.length;\n  \n  while (swapped) {\n    swapped = false;\n    for (int i = start; i < end - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    \n    if (!swapped) break;\n    \n    swapped = false;\n    end--;\n    \n    for (int i = end - 1; i >= start; i--) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    start++;\n  }\n}`,\n    python: `def cocktail_sort(arr):\n  n = len(arr)\n  swapped = True\n  start = 0\n  end = n - 1\n  \n  while swapped:\n    swapped = False\n    for i in range(start, end):\n      if arr[i] > arr[i + 1]:\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n        swapped = True\n        \n    if not swapped:\n      break\n      \n    swapped = False\n    end -= 1\n    \n    for i in range(end - 1, start - 1, -1):\n      if arr[i] > arr[i + 1]:\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n        swapped = True\n        \n    start += 1`,\n    php: `function cocktailSort($arr) {\n  $n = count($arr);\n  $swapped = true;\n  $start = 0;\n  $end = $n - 1;\n  \n  while ($swapped) {\n    $swapped = false;\n    for ($i = $start; $i < $end; $i++) {\n      if ($arr[$i] > $arr[$i + 1]) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$i + 1];\n        $arr[$i + 1] = $temp;\n        $swapped = true;\n      }\n    }\n    \n    if (!$swapped) break;\n    \n    $swapped = false;\n    $end--;\n    \n    for ($i = $end - 1; $i >= $start; $i--) {\n      if ($arr[$i] > $arr[$i + 1]) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$i + 1];\n        $arr[$i + 1] = $temp;\n        $swapped = true;\n      }\n    }\n    $start++;\n  }\n  return $arr;\n}`,\n    javascript: `function cocktailSort(arr) {\n  let swapped = true;\n  let start = 0;\n  let end = arr.length;\n  \n  while (swapped) {\n    swapped = false;\n    for (let i = start; i < end - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n        swapped = true;\n      }\n    }\n    \n    if (!swapped) break;\n    \n    swapped = false;\n    end--;\n    \n    for (let i = end - 1; i >= start; i--) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n        swapped = true;\n      }\n    }\n    start++;\n  }\n}`,\n    csharp: `public void CocktailSort(int[] arr) {\n  bool swapped = true;\n  int start = 0;\n  int end = arr.Length;\n  \n  while (swapped) {\n    swapped = false;\n    for (int i = start; i < end - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    \n    if (!swapped) break;\n    \n    swapped = false;\n    end--;\n    \n    for (int i = end - 1; i >= start; i--) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    start++;\n  }\n}`\n  }\n}, {\n  id: 'gnome-sort',\n  name: 'Gnome Sort',\n  description: 'A sorting algorithm similar to insertion sort, but moving elements to their proper place by a series of swaps.',\n  complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void gnomeSort(int[] arr) {\n  int index = 0;\n  while (index < arr.length) {\n    if (index == 0)\n      index++;\n    if (arr[index] >= arr[index - 1])\n      index++;\n    else {\n      int temp = arr[index];\n      arr[index] = arr[index - 1];\n      arr[index - 1] = temp;\n      index--;\n    }\n  }\n}`,\n    python: `def gnome_sort(arr):\n  index = 0\n  while index < len(arr):\n    if index == 0:\n      index += 1\n    if arr[index] >= arr[index - 1]:\n      index += 1\n    else:\n      arr[index], arr[index - 1] = arr[index - 1], arr[index]\n      index -= 1`,\n    php: `function gnomeSort($arr) {\n  $index = 0;\n  while ($index < count($arr)) {\n    if ($index == 0)\n      $index++;\n    if ($arr[$index] >= $arr[$index - 1])\n      $index++;\n    else {\n      $temp = $arr[$index];\n      $arr[$index] = $arr[$index - 1];\n      $arr[$index - 1] = $temp;\n      $index--;\n    }\n  }\n  return $arr;\n}`,\n    javascript: `function gnomeSort(arr) {\n  let index = 0;\n  while (index < arr.length) {\n    if (index == 0)\n      index++;\n    if (arr[index] >= arr[index - 1])\n      index++;\n    else {\n      [arr[index], arr[index - 1]] = [arr[index - 1], arr[index]];\n      index--;\n    }\n  }\n}`,\n    csharp: `public void GnomeSort(int[] arr) {\n  int index = 0;\n  while (index < arr.Length) {\n    if (index == 0)\n      index++;\n    if (arr[index] >= arr[index - 1])\n      index++;\n    else {\n      int temp = arr[index];\n      arr[index] = arr[index - 1];\n      arr[index - 1] = temp;\n      index--;\n    }\n  }\n}`\n  }\n}, {\n  id: 'comb-sort',\n  name: 'Comb Sort',\n  description: 'An improvement over bubble sort that uses a gap sequence to eliminate turtles.',\n  complexity: 'Best: O(n log n), Average: O(n²/2^p), Worst: O(n²)',\n  code: {\n    java: `public void combSort(int[] arr) {\n  int n = arr.length;\n  int gap = n;\n  boolean swapped = true;\n  \n  while (gap != 1 || swapped) {\n    gap = getNextGap(gap);\n    swapped = false;\n    \n    for (int i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        int temp = arr[i];\n        arr[i] = arr[i + gap];\n        arr[i + gap] = temp;\n        swapped = true;\n      }\n    }\n  }\n}\n\nprivate int getNextGap(int gap) {\n  gap = (gap * 10) / 13;\n  return Math.max(1, gap);\n}`,\n    python: `def get_next_gap(gap):\n  gap = (gap * 10) // 13\n  return max(1, gap)\n\ndef comb_sort(arr):\n  n = len(arr)\n  gap = n\n  swapped = True\n  \n  while gap != 1 or swapped:\n    gap = get_next_gap(gap)\n    swapped = False\n    \n    for i in range(n - gap):\n      if arr[i] > arr[i + gap]:\n        arr[i], arr[i + gap] = arr[i + gap], arr[i]\n        swapped = True`,\n    php: `function getNextGap($gap) {\n  $gap = ($gap * 10) / 13;\n  return max(1, $gap);\n}\n\nfunction combSort($arr) {\n  $n = count($arr);\n  $gap = $n;\n  $swapped = true;\n  \n  while ($gap != 1 || $swapped) {\n    $gap = getNextGap($gap);\n    $swapped = false;\n    \n    for ($i = 0; $i < $n - $gap; $i++) {\n      if ($arr[$i] > $arr[$i + $gap]) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$i + $gap];\n        $arr[$i + $gap] = $temp;\n        $swapped = true;\n      }\n    }\n  }\n  return $arr;\n}`,\n    javascript: `function getNextGap(gap) {\n  gap = (gap * 10) / 13;\n  return Math.max(1, Math.floor(gap));\n}\n\nfunction combSort(arr) {\n  let n = arr.length;\n  let gap = n;\n  let swapped = true;\n  \n  while (gap != 1 || swapped) {\n    gap = getNextGap(gap);\n    swapped = false;\n    \n    for (let i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        [arr[i], arr[i + gap]] = [arr[i + gap], arr[i]];\n        swapped = true;\n      }\n    }\n  }\n}`,\n    csharp: `private int GetNextGap(int gap) {\n  gap = (gap * 10) / 13;\n  return Math.Max(1, gap);\n}\n\npublic void CombSort(int[] arr) {\n  int n = arr.Length;\n  int gap = n;\n  bool swapped = true;\n  \n  while (gap != 1 || swapped) {\n    gap = GetNextGap(gap);\n    swapped = false;\n    \n    for (int i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        int temp = arr[i];\n        arr[i] = arr[i + gap];\n        arr[i + gap] = temp;\n        swapped = true;\n      }\n    }\n  }\n}`\n  }\n}, {\n  id: 'cycle-sort',\n  name: 'Cycle Sort',\n  description: 'An in-place sorting algorithm that minimizes the number of writes to memory.',\n  complexity: 'Best: O(n²), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void cycleSort(int[] arr) {\n  int n = arr.length;\n  \n  for (int cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n    int item = arr[cycleStart];\n    int pos = cycleStart;\n    \n    for (int i = cycleStart + 1; i < n; i++)\n      if (arr[i] < item)\n        pos++;\n        \n    if (pos == cycleStart)\n      continue;\n      \n    while (item == arr[pos])\n      pos++;\n      \n    int temp = arr[pos];\n    arr[pos] = item;\n    item = temp;\n    \n    while (pos != cycleStart) {\n      pos = cycleStart;\n      for (int i = cycleStart + 1; i < n; i++)\n        if (arr[i] < item)\n          pos++;\n          \n      while (item == arr[pos])\n        pos++;\n        \n      temp = arr[pos];\n      arr[pos] = item;\n      item = temp;\n    }\n  }\n}`,\n    python: `def cycle_sort(arr):\n  n = len(arr)\n  \n  for cycle_start in range(n - 1):\n    item = arr[cycle_start]\n    pos = cycle_start\n    \n    for i in range(cycle_start + 1, n):\n      if arr[i] < item:\n        pos += 1\n        \n    if pos == cycle_start:\n      continue\n      \n    while item == arr[pos]:\n      pos += 1\n      \n    arr[pos], item = item, arr[pos]\n    \n    while pos != cycle_start:\n      pos = cycle_start\n      for i in range(cycle_start + 1, n):\n        if arr[i] < item:\n          pos += 1\n          \n      while item == arr[pos]:\n        pos += 1\n        \n      arr[pos], item = item, arr[pos]`,\n    php: `function cycleSort($arr) {\n  $n = count($arr);\n  \n  for ($cycleStart = 0; $cycleStart < $n - 1; $cycleStart++) {\n    $item = $arr[$cycleStart];\n    $pos = $cycleStart;\n    \n    for ($i = $cycleStart + 1; $i < $n; $i++)\n      if ($arr[$i] < $item)\n        $pos++;\n        \n    if ($pos == $cycleStart)\n      continue;\n      \n    while ($item == $arr[$pos])\n      $pos++;\n      \n    $temp = $arr[$pos];\n    $arr[$pos] = $item;\n    $item = $temp;\n    \n    while ($pos != $cycleStart) {\n      $pos = $cycleStart;\n      for ($i = $cycleStart + 1; $i < $n; $i++)\n        if ($arr[$i] < $item)\n          $pos++;\n          \n      while ($item == $arr[$pos])\n        $pos++;\n        \n      $temp = $arr[$pos];\n      $arr[$pos] = $item;\n      $item = $temp;\n    }\n  }\n  return $arr;\n}`,\n    javascript: `function cycleSort(arr) {\n  const n = arr.length;\n  \n  for (let cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n    let item = arr[cycleStart];\n    let pos = cycleStart;\n    \n    for (let i = cycleStart + 1; i < n; i++)\n      if (arr[i] < item)\n        pos++;\n        \n    if (pos == cycleStart)\n      continue;\n      \n    while (item == arr[pos])\n      pos++;\n      \n    [arr[pos], item] = [item, arr[pos]];\n    \n    while (pos != cycleStart) {\n      pos = cycleStart;\n      for (let i = cycleStart + 1; i < n; i++)\n        if (arr[i] < item)\n          pos++;\n          \n      while (item == arr[pos])\n        pos++;\n        \n      [arr[pos], item] = [item, arr[pos]];\n    }\n  }\n}`,\n    csharp: `public void CycleSort(int[] arr) {\n  int n = arr.Length;\n  \n  for (int cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n    int item = arr[cycleStart];\n    int pos = cycleStart;\n    \n    for (int i = cycleStart + 1; i < n; i++)\n      if (arr[i] < item)\n        pos++;\n        \n    if (pos == cycleStart)\n      continue;\n      \n    while (item == arr[pos])\n      pos++;\n      \n    int temp = arr[pos];\n    arr[pos] = item;\n    item = temp;\n    \n    while (pos != cycleStart) {\n      pos = cycleStart;\n      for (int i = cycleStart + 1; i < n; i++)\n        if (arr[i] < item)\n          pos++;\n          \n      while (item == arr[pos])\n        pos++;\n        \n      temp = arr[pos];\n      arr[pos] = item;\n      item = temp;\n    }\n  }\n}`\n  }\n}, {\n  id: 'pancake-sort',\n  name: 'Pancake Sort',\n  description: 'A sorting algorithm that sorts an array by repeatedly flipping portions of the array.',\n  complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n  code: {\n    java: `public void pancakeSort(int[] arr) {\n  for (int currSize = arr.length; currSize > 1; currSize--) {\n    int mi = findMax(arr, currSize);\n    if (mi != currSize - 1) {\n      flip(arr, mi);\n      flip(arr, currSize - 1);\n    }\n  }\n}\n\nprivate int findMax(int[] arr, int n) {\n  int mi = 0;\n  for (int i = 0; i < n; i++)\n    if (arr[i] > arr[mi])\n      mi = i;\n  return mi;\n}\n\nprivate void flip(int[] arr, int i) {\n  int start = 0;\n  while (start < i) {\n    int temp = arr[start];\n    arr[start] = arr[i];\n    arr[i] = temp;\n    start++;\n    i--;\n  }\n}`,\n    python: `def find_max(arr, n):\n  mi = 0\n  for i in range(n):\n    if arr[i] > arr[mi]:\n      mi = i\n  return mi\n\ndef flip(arr, i):\n  start = 0\n  while start < i:\n    arr[start], arr[i] = arr[i], arr[start]\n    start += 1\n    i -= 1\n\ndef pancake_sort(arr):\n  curr_size = len(arr)\n  while curr_size > 1:\n    mi = find_max(arr, curr_size)\n    if mi != curr_size - 1:\n      flip(arr, mi)\n      flip(arr, curr_size - 1)\n    curr_size -= 1`,\n    php: `function findMax($arr, $n) {\n  $mi = 0;\n  for ($i = 0; $i < $n; $i++)\n    if ($arr[$i] > $arr[$mi])\n      $mi = $i;\n  return $mi;\n}\n\nfunction flip(&$arr, $i) {\n  $start = 0;\n  while ($start < $i) {\n    $temp = $arr[$start];\n    $arr[$start] = $arr[$i];\n    $arr[$i] = $temp;\n    $start++;\n    $i--;\n  }\n}\n\nfunction pancakeSort($arr) {\n  $curr_size = count($arr);\n  while ($curr_size > 1) {\n    $mi = findMax($arr, $curr_size);\n    if ($mi != $curr_size - 1) {\n      flip($arr, $mi);\n      flip($arr, $curr_size - 1);\n    }\n    $curr_size--;\n  }\n  return $arr;\n}`,\n    javascript: `function findMax(arr, n) {\n  let mi = 0;\n  for (let i = 0; i < n; i++)\n    if (arr[i] > arr[mi])\n      mi = i;\n  return mi;\n}\n\nfunction flip(arr, i) {\n  let start = 0;\n  while (start < i) {\n    [arr[start], arr[i]] = [arr[i], arr[start]];\n    start++;\n    i--;\n  }\n}\n\nfunction pancakeSort(arr) {\n  let currSize = arr.length;\n  while (currSize > 1) {\n    const mi = findMax(arr, currSize);\n    if (mi != currSize - 1) {\n      flip(arr, mi);\n      flip(arr, currSize - 1);\n    }\n    currSize--;\n  }\n}`,\n    csharp: `private int FindMax(int[] arr, int n) {\n  int mi = 0;\n  for (int i = 0; i < n; i++)\n    if (arr[i] > arr[mi])\n      mi = i;\n  return mi;\n}\n\nprivate void Flip(int[] arr, int i) {\n  int start = 0;\n  while (start < i) {\n    int temp = arr[start];\n    arr[start] = arr[i];\n    arr[i] = temp;\n    start++;\n    i--;\n  }\n}\n\npublic void PancakeSort(int[] arr) {\n  int currSize = arr.Length;\n  while (currSize > 1) {\n    int mi = FindMax(arr, currSize);\n    if (mi != currSize - 1) {\n      Flip(arr, mi);\n      Flip(arr, currSize - 1);\n    }\n    currSize--;\n  }\n}`\n  }\n}, {\n  id: 'bogo-sort',\n  name: 'Bogo Sort',\n  description: 'A highly inefficient sorting algorithm that randomly shuffles the array until it is sorted. This algorithm is mainly used for educational purposes to demonstrate the worst-case scenario of sorting algorithms.',\n  complexity: 'Best: O(1), Average: O(n * n!), Worst: O(∞)',\n  code: {\n    java: `public void bogoSort(int[] arr) {\n  while (!isSorted(arr)) {\n    shuffle(arr);\n  }\n}\n\nprivate boolean isSorted(int[] arr) {\n  for (int i = 0; i < arr.length - 1; i++) {\n    if (arr[i] > arr[i + 1]) return false;\n  }\n  return true;\n}\n\nprivate void shuffle(int[] arr) {\n  Random rand = new Random();\n  for (int i = arr.length - 1; i > 0; i--) {\n    int j = rand.nextInt(i + 1);\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n}`,\n    python: `def bogo_sort(arr):\n  while not is_sorted(arr):\n    shuffle(arr)\n\ndef is_sorted(arr):\n  for i in range(len(arr) - 1):\n    if arr[i] > arr[i + 1]:\n      return False\n  return True\n\ndef shuffle(arr):\n  import random\n  for i in range(len(arr) - 1, 0, -1):\n    j = random.randint(0, i)\n    arr[i], arr[j] = arr[j], arr[i]`,\n    php: `function bogoSort(&$arr) {\n  while (!isSorted($arr)) {\n    shuffle($arr);\n  }\n}\n\nfunction isSorted($arr) {\n  for ($i = 0; $i < count($arr) - 1; $i++) {\n    if ($arr[$i] > $arr[$i + 1]) return false;\n  }\n  return true;\n}\n\nfunction shuffle(&$arr) {\n  for ($i = count($arr) - 1; $i > 0; $i--) {\n    $j = rand(0, $i);\n    $temp = $arr[$i];\n    $arr[$i] = $arr[$j];\n    $arr[$j] = $temp;\n  }\n}`,\n    javascript: `function bogoSort(arr) {\n  while (!isSorted(arr)) {\n    shuffle(arr);\n  }\n}\n\nfunction isSorted(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] > arr[i + 1]) return false;\n  }\n  return true;\n}\n\nfunction shuffle(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n}`,\n    csharp: `public void BogoSort(int[] arr)\n{\n    while (!IsSorted(arr))\n    {\n        Shuffle(arr);\n    }\n}\n\nprivate bool IsSorted(int[] arr)\n{\n    for (int i = 0; i < arr.Length - 1; i++)\n    {\n        if (arr[i] > arr[i + 1]) return false;\n    }\n    return true;\n}\n\nprivate void Shuffle(int[] arr)\n{\n    Random rand = new Random();\n    for (int i = arr.Length - 1; i > 0; i--)\n    {\n        int j = rand.Next(i + 1);\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}`\n  }\n}];","map":{"version":3,"names":["algorithms","id","name","description","complexity","code","java","python","php","javascript","csharp"],"sources":["/Users/santigomez/Documents/Proyectos Personales/sortlab/src/data/algorithms.ts"],"sourcesContent":["export interface Algorithm {\n  id: string;\n  name: string;\n  description: string;\n  complexity: string;\n  code: {\n    java: string;\n    python: string;\n    php: string;\n    javascript: string;\n    csharp: string;\n  };\n}\n\nexport const algorithms: Algorithm[] = [\n  {\n    id: 'bubble-sort',\n    name: 'Bubble Sort',\n    description: 'Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.',\n    complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void bubbleSort(int[] arr) {\n  int n = arr.length;\n  for (int i = 0; i < n-1; i++) {\n    for (int j = 0; j < n-i-1; j++) {\n      if (arr[j] > arr[j+1]) {\n        int temp = arr[j];\n        arr[j] = arr[j+1];\n        arr[j+1] = temp;\n      }\n    }\n  }\n}`,\n      python: `def bubble_sort(arr):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] = arr[j+1], arr[j]`,\n      php: `function bubbleSort(&$arr) {\n  $n = count($arr);\n  for ($i = 0; $i < $n-1; $i++) {\n    for ($j = 0; $j < $n-$i-1; $j++) {\n      if ($arr[$j] > $arr[$j+1]) {\n        $temp = $arr[$j];\n        $arr[$j] = $arr[$j+1];\n        $arr[$j+1] = $temp;\n      }\n    }\n  }\n}`,\n      javascript: `function bubbleSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n-1; i++) {\n    for (let j = 0; j < n-i-1; j++) {\n      if (arr[j] > arr[j+1]) {\n        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];\n      }\n    }\n  }\n}`,\n      csharp: `public void BubbleSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = 0; i < n-1; i++) {\n    for (int j = 0; j < n-i-1; j++) {\n      if (arr[j] > arr[j+1]) {\n        int temp = arr[j];\n        arr[j] = arr[j+1];\n        arr[j+1] = temp;\n      }\n    }\n  }\n}`\n    }\n  },\n  {\n    id: 'quick-sort',\n    name: 'Quick Sort',\n    description: 'A divide and conquer algorithm that works by selecting a pivot element and partitioning the array around the pivot.',\n    complexity: 'Best: O(n log n), Average: O(n log n), Worst: O(n²)',\n    code: {\n      java: `public void quickSort(int[] arr, int low, int high) {\n  if (low < high) {\n    int pi = partition(arr, low, high);\n    quickSort(arr, low, pi-1);\n    quickSort(arr, pi+1, high);\n  }\n}\n\nprivate int partition(int[] arr, int low, int high) {\n  int pivot = arr[high];\n  int i = (low-1);\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      int temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n  int temp = arr[i+1];\n  arr[i+1] = arr[high];\n  arr[high] = temp;\n  return i+1;\n}`,\n      python: `def quick_sort(arr, low, high):\n  if low < high:\n    pi = partition(arr, low, high)\n    quick_sort(arr, low, pi-1)\n    quick_sort(arr, pi+1, high)\n\ndef partition(arr, low, high):\n  pivot = arr[high]\n  i = low - 1\n  for j in range(low, high):\n    if arr[j] < pivot:\n      i += 1\n      arr[i], arr[j] = arr[j], arr[i]\n  arr[i+1], arr[high] = arr[high], arr[i+1]\n  return i+1`,\n      php: `function quickSort($arr, $low, $high) {\n  if ($low < $high) {\n    $pi = partition($arr, $low, $high);\n    quickSort($arr, $low, $pi-1);\n    quickSort($arr, $pi+1, $high);\n  }\n  return $arr;\n}\n\nfunction partition($arr, $low, $high) {\n  $pivot = $arr[$high];\n  $i = $low - 1;\n  for ($j = $low; $j < $high; $j++) {\n    if ($arr[$j] < $pivot) {\n      $i++;\n      $temp = $arr[$i];\n      $arr[$i] = $arr[$j];\n      $arr[$j] = $temp;\n    }\n  }\n  $temp = $arr[$i+1];\n  $arr[$i+1] = $arr[$high];\n  $arr[$high] = $temp;\n  return $i+1;\n}`,\n      javascript: `function quickSort(arr, low, high) {\n  if (low < high) {\n    const pi = partition(arr, low, high);\n    quickSort(arr, low, pi-1);\n    quickSort(arr, pi+1, high);\n  }\n}\n\nfunction partition(arr, low, high) {\n  const pivot = arr[high];\n  let i = low - 1;\n  for (let j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i+1], arr[high]] = [arr[high], arr[i+1]];\n  return i+1;\n}`,\n      csharp: `public void QuickSort(int[] arr, int low, int high) {\n  if (low < high) {\n    int pi = Partition(arr, low, high);\n    QuickSort(arr, low, pi-1);\n    QuickSort(arr, pi+1, high);\n  }\n}\n\nprivate int Partition(int[] arr, int low, int high) {\n  int pivot = arr[high];\n  int i = low - 1;\n  for (int j = low; j < high; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      int temp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = temp;\n    }\n  }\n  int temp = arr[i+1];\n  arr[i+1] = arr[high];\n  arr[high] = temp;\n  return i+1;\n}`\n    }\n  },\n  {\n    id: 'merge-sort',\n    name: 'Merge Sort',\n    description: 'A divide and conquer algorithm that divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.',\n    complexity: 'Best: O(n log n), Average: O(n log n), Worst: O(n log n)',\n    code: {\n      java: `public void mergeSort(int[] arr, int left, int right) {\n  if (left < right) {\n    int middle = (left + right) / 2;\n    mergeSort(arr, left, middle);\n    mergeSort(arr, middle + 1, right);\n    merge(arr, left, middle, right);\n  }\n}\n\nprivate void merge(int[] arr, int left, int middle, int right) {\n  int n1 = middle - left + 1;\n  int n2 = right - middle;\n  int[] L = new int[n1];\n  int[] R = new int[n2];\n  \n  for (int i = 0; i < n1; i++)\n    L[i] = arr[left + i];\n  for (int j = 0; j < n2; j++)\n    R[j] = arr[middle + 1 + j];\n    \n  int i = 0, j = 0, k = left;\n  while (i < n1 && j < n2) {\n    if (L[i] <= R[j]) {\n      arr[k] = L[i];\n      i++;\n    } else {\n      arr[k] = R[j];\n      j++;\n    }\n    k++;\n  }\n  \n  while (i < n1) {\n    arr[k] = L[i];\n    i++;\n    k++;\n  }\n  \n  while (j < n2) {\n    arr[k] = R[j];\n    j++;\n    k++;\n  }\n}`,\n      python: `def merge_sort(arr):\n  if len(arr) > 1:\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    \n    merge_sort(left)\n    merge_sort(right)\n    \n    i = j = k = 0\n    while i < len(left) and j < len(right):\n      if left[i] < right[j]:\n        arr[k] = left[i]\n        i += 1\n      else:\n        arr[k] = right[j]\n        j += 1\n      k += 1\n      \n    while i < len(left):\n      arr[k] = left[i]\n      i += 1\n      k += 1\n      \n    while j < len(right):\n      arr[k] = right[j]\n      j += 1\n      k += 1`,\n      php: `function mergeSort($arr) {\n  if (count($arr) <= 1) return $arr;\n  \n  $mid = floor(count($arr) / 2);\n  $left = array_slice($arr, 0, $mid);\n  $right = array_slice($arr, $mid);\n  \n  $left = mergeSort($left);\n  $right = mergeSort($right);\n  \n  return merge($left, $right);\n}\n\nfunction merge($left, $right) {\n  $result = [];\n  $i = $j = 0;\n  \n  while ($i < count($left) && $j < count($right)) {\n    if ($left[$i] <= $right[$j]) {\n      $result[] = $left[$i];\n      $i++;\n    } else {\n      $result[] = $right[$j];\n      $j++;\n    }\n  }\n  \n  while ($i < count($left)) {\n    $result[] = $left[$i];\n    $i++;\n  }\n  \n  while ($j < count($right)) {\n    $result[] = $right[$j];\n    $j++;\n  }\n  \n  return $result;\n}`,\n      javascript: `function mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  \n  const mid = Math.floor(arr.length / 2);\n  const left = arr.slice(0, mid);\n  const right = arr.slice(mid);\n  \n  return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right) {\n  let result = [];\n  let i = 0, j = 0;\n  \n  while (i < left.length && j < right.length) {\n    if (left[i] <= right[j]) {\n      result.push(left[i]);\n      i++;\n    } else {\n      result.push(right[j]);\n      j++;\n    }\n  }\n  \n  return result.concat(left.slice(i)).concat(right.slice(j));\n}`,\n      csharp: `public void MergeSort(int[] arr, int left, int right) {\n  if (left < right) {\n    int middle = (left + right) / 2;\n    MergeSort(arr, left, middle);\n    MergeSort(arr, middle + 1, right);\n    Merge(arr, left, middle, right);\n  }\n}\n\nprivate void Merge(int[] arr, int left, int middle, int right) {\n  int n1 = middle - left + 1;\n  int n2 = right - middle;\n  int[] L = new int[n1];\n  int[] R = new int[n2];\n  \n  for (int i = 0; i < n1; i++)\n    L[i] = arr[left + i];\n  for (int j = 0; j < n2; j++)\n    R[j] = arr[middle + 1 + j];\n    \n  int i = 0, j = 0, k = left;\n  while (i < n1 && j < n2) {\n    if (L[i] <= R[j]) {\n      arr[k] = L[i];\n      i++;\n    } else {\n      arr[k] = R[j];\n      j++;\n    }\n    k++;\n  }\n  \n  while (i < n1) {\n    arr[k] = L[i];\n    i++;\n    k++;\n  }\n  \n  while (j < n2) {\n    arr[k] = R[j];\n    j++;\n    k++;\n  }\n}`\n    }\n  },\n  {\n    id: 'insertion-sort',\n    name: 'Insertion Sort',\n    description: 'A simple sorting algorithm that builds the final sorted array one item at a time.',\n    complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void insertionSort(int[] arr) {\n  int n = arr.length;\n  for (int i = 1; i < n; i++) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n}`,\n      python: `def insertion_sort(arr):\n  for i in range(1, len(arr)):\n    key = arr[i]\n    j = i - 1\n    while j >= 0 and arr[j] > key:\n      arr[j + 1] = arr[j]\n      j -= 1\n    arr[j + 1] = key`,\n      php: `function insertionSort($arr) {\n  $n = count($arr);\n  for ($i = 1; $i < $n; $i++) {\n    $key = $arr[$i];\n    $j = $i - 1;\n    while ($j >= 0 && $arr[$j] > $key) {\n      $arr[$j + 1] = $arr[$j];\n      $j = $j - 1;\n    }\n    $arr[$j + 1] = $key;\n  }\n  return $arr;\n}`,\n      javascript: `function insertionSort(arr) {\n  const n = arr.length;\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n}`,\n      csharp: `public void InsertionSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = 1; i < n; i++) {\n    int key = arr[i];\n    int j = i - 1;\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n    }\n    arr[j + 1] = key;\n  }\n}`\n    }\n  },\n  {\n    id: 'selection-sort',\n    name: 'Selection Sort',\n    description: 'A sorting algorithm that repeatedly finds the minimum element from the unsorted part and puts it at the beginning.',\n    complexity: 'Best: O(n²), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void selectionSort(int[] arr) {\n  int n = arr.length;\n  for (int i = 0; i < n-1; i++) {\n    int min_idx = i;\n    for (int j = i+1; j < n; j++) {\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n    int temp = arr[min_idx];\n    arr[min_idx] = arr[i];\n    arr[i] = temp;\n  }\n}`,\n      python: `def selection_sort(arr):\n  n = len(arr)\n  for i in range(n):\n    min_idx = i\n    for j in range(i+1, n):\n      if arr[j] < arr[min_idx]:\n        min_idx = j\n    arr[i], arr[min_idx] = arr[min_idx], arr[i]`,\n      php: `function selectionSort($arr) {\n  $n = count($arr);\n  for ($i = 0; $i < $n-1; $i++) {\n    $min_idx = $i;\n    for ($j = $i+1; $j < $n; $j++) {\n      if ($arr[$j] < $arr[$min_idx]) {\n        $min_idx = $j;\n      }\n    }\n    $temp = $arr[$min_idx];\n    $arr[$min_idx] = $arr[$i];\n    $arr[$i] = $temp;\n  }\n  return $arr;\n}`,\n      javascript: `function selectionSort(arr) {\n  const n = arr.length;\n  for (let i = 0; i < n-1; i++) {\n    let min_idx = i;\n    for (let j = i+1; j < n; j++) {\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n    [arr[i], arr[min_idx]] = [arr[min_idx], arr[i]];\n  }\n}`,\n      csharp: `public void SelectionSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = 0; i < n-1; i++) {\n    int min_idx = i;\n    for (int j = i+1; j < n; j++) {\n      if (arr[j] < arr[min_idx]) {\n        min_idx = j;\n      }\n    }\n    int temp = arr[min_idx];\n    arr[min_idx] = arr[i];\n    arr[i] = temp;\n  }\n}`\n    }\n  },\n  {\n    id: 'heap-sort',\n    name: 'Heap Sort',\n    description: 'A comparison-based sorting algorithm that uses a binary heap data structure to sort elements.',\n    complexity: 'Best: O(n log n), Average: O(n log n), Worst: O(n log n)',\n    code: {\n      java: `public void heapSort(int[] arr) {\n  int n = arr.length;\n  for (int i = n / 2 - 1; i >= 0; i--)\n    heapify(arr, n, i);\n  for (int i = n - 1; i > 0; i--) {\n    int temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    heapify(arr, i, 0);\n  }\n}\n\nprivate void heapify(int[] arr, int n, int i) {\n  int largest = i;\n  int l = 2 * i + 1;\n  int r = 2 * i + 2;\n  if (l < n && arr[l] > arr[largest])\n    largest = l;\n  if (r < n && arr[r] > arr[largest])\n    largest = r;\n  if (largest != i) {\n    int swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap;\n    heapify(arr, n, largest);\n  }\n}`,\n      python: `def heapify(arr, n, i):\n  largest = i\n  l = 2 * i + 1\n  r = 2 * i + 2\n  if l < n and arr[i] < arr[l]:\n    largest = l\n  if r < n and arr[largest] < arr[r]:\n    largest = r\n  if largest != i:\n    arr[i], arr[largest] = arr[largest], arr[i]\n    heapify(arr, n, largest)\n\ndef heap_sort(arr):\n  n = len(arr)\n  for i in range(n//2 - 1, -1, -1):\n    heapify(arr, n, i)\n  for i in range(n-1, 0, -1):\n    arr[i], arr[0] = arr[0], arr[i]\n    heapify(arr, i, 0)`,\n      php: `function heapify(&$arr, $n, $i) {\n  $largest = $i;\n  $l = 2 * $i + 1;\n  $r = 2 * $i + 2;\n  if ($l < $n && $arr[$l] > $arr[$largest])\n    $largest = $l;\n  if ($r < $n && $arr[$r] > $arr[$largest])\n    $largest = $r;\n  if ($largest != $i) {\n    $swap = $arr[$i];\n    $arr[$i] = $arr[$largest];\n    $arr[$largest] = $swap;\n    heapify($arr, $n, $largest);\n  }\n}\n\nfunction heapSort($arr) {\n  $n = count($arr);\n  for ($i = $n / 2 - 1; $i >= 0; $i--)\n    heapify($arr, $n, $i);\n  for ($i = $n - 1; $i > 0; $i--) {\n    $temp = $arr[0];\n    $arr[0] = $arr[$i];\n    $arr[$i] = $temp;\n    heapify($arr, $i, 0);\n  }\n  return $arr;\n}`,\n      javascript: `function heapify(arr, n, i) {\n  let largest = i;\n  let l = 2 * i + 1;\n  let r = 2 * i + 2;\n  if (l < n && arr[l] > arr[largest])\n    largest = l;\n  if (r < n && arr[r] > arr[largest])\n    largest = r;\n  if (largest != i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n\nfunction heapSort(arr) {\n  const n = arr.length;\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--)\n    heapify(arr, n, i);\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n}`,\n      csharp: `public void HeapSort(int[] arr) {\n  int n = arr.Length;\n  for (int i = n / 2 - 1; i >= 0; i--)\n    Heapify(arr, n, i);\n  for (int i = n - 1; i > 0; i--) {\n    int temp = arr[0];\n    arr[0] = arr[i];\n    arr[i] = temp;\n    Heapify(arr, i, 0);\n  }\n}\n\nprivate void Heapify(int[] arr, int n, int i) {\n  int largest = i;\n  int l = 2 * i + 1;\n  int r = 2 * i + 2;\n  if (l < n && arr[l] > arr[largest])\n    largest = l;\n  if (r < n && arr[r] > arr[largest])\n    largest = r;\n  if (largest != i) {\n    int swap = arr[i];\n    arr[i] = arr[largest];\n    arr[largest] = swap;\n    Heapify(arr, n, largest);\n  }\n}`\n    }\n  },\n  {\n    id: 'shell-sort',\n    name: 'Shell Sort',\n    description: 'An optimization of insertion sort that allows the exchange of items that are far apart.',\n    complexity: 'Best: O(n log n), Average: O(n log² n), Worst: O(n²)',\n    code: {\n      java: `public void shellSort(int[] arr) {\n  int n = arr.length;\n  for (int gap = n/2; gap > 0; gap /= 2) {\n    for (int i = gap; i < n; i++) {\n      int temp = arr[i];\n      int j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n        arr[j] = arr[j - gap];\n      arr[j] = temp;\n    }\n  }\n}`,\n      python: `def shell_sort(arr):\n  n = len(arr)\n  gap = n // 2\n  while gap > 0:\n    for i in range(gap, n):\n      temp = arr[i]\n      j = i\n      while j >= gap and arr[j - gap] > temp:\n        arr[j] = arr[j - gap]\n        j -= gap\n      arr[j] = temp\n    gap //= 2`,\n      php: `function shellSort($arr) {\n  $n = count($arr);\n  for ($gap = $n/2; $gap > 0; $gap /= 2) {\n    for ($i = $gap; $i < $n; $i++) {\n      $temp = $arr[$i];\n      for ($j = $i; $j >= $gap && $arr[$j - $gap] > $temp; $j -= $gap)\n        $arr[$j] = $arr[$j - $gap];\n      $arr[$j] = $temp;\n    }\n  }\n  return $arr;\n}`,\n      javascript: `function shellSort(arr) {\n  const n = arr.length;\n  for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2)) {\n    for (let i = gap; i < n; i++) {\n      let temp = arr[i];\n      let j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n        arr[j] = arr[j - gap];\n      arr[j] = temp;\n    }\n  }\n}`,\n      csharp: `public void ShellSort(int[] arr) {\n  int n = arr.Length;\n  for (int gap = n/2; gap > 0; gap /= 2) {\n    for (int i = gap; i < n; i++) {\n      int temp = arr[i];\n      int j;\n      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap)\n        arr[j] = arr[j - gap];\n      arr[j] = temp;\n    }\n  }\n}`\n    }\n  },\n  {\n    id: 'counting-sort',\n    name: 'Counting Sort',\n    description: 'A sorting algorithm that works by counting the number of objects having distinct key values.',\n    complexity: 'Best: O(n + k), Average: O(n + k), Worst: O(n + k)',\n    code: {\n      java: `public void countingSort(int[] arr) {\n  int max = Arrays.stream(arr).max().getAsInt();\n  int min = Arrays.stream(arr).min().getAsInt();\n  int range = max - min + 1;\n  int[] count = new int[range];\n  int[] output = new int[arr.length];\n  \n  for (int i = 0; i < arr.length; i++)\n    count[arr[i] - min]++;\n  \n  for (int i = 1; i < count.length; i++)\n    count[i] += count[i - 1];\n  \n  for (int i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n  \n  System.arraycopy(output, 0, arr, 0, arr.length);\n}`,\n      python: `def counting_sort(arr):\n  max_val = max(arr)\n  min_val = min(arr)\n  range_val = max_val - min_val + 1\n  count = [0] * range_val\n  output = [0] * len(arr)\n  \n  for i in range(len(arr)):\n    count[arr[i] - min_val] += 1\n    \n  for i in range(1, len(count)):\n    count[i] += count[i - 1]\n    \n  for i in range(len(arr) - 1, -1, -1):\n    output[count[arr[i] - min_val] - 1] = arr[i]\n    count[arr[i] - min_val] -= 1\n    \n  for i in range(len(arr)):\n    arr[i] = output[i]`,\n      php: `function countingSort($arr) {\n  $max = max($arr);\n  $min = min($arr);\n  $range = $max - $min + 1;\n  $count = array_fill(0, $range, 0);\n  $output = array_fill(0, count($arr), 0);\n  \n  for ($i = 0; $i < count($arr); $i++)\n    $count[$arr[$i] - $min]++;\n    \n  for ($i = 1; $i < count($count); $i++)\n    $count[$i] += $count[$i - 1];\n    \n  for ($i = count($arr) - 1; $i >= 0; $i--) {\n    $output[$count[$arr[$i] - $min] - 1] = $arr[$i];\n    $count[$arr[$i] - $min]--;\n  }\n  \n  for ($i = 0; $i < count($arr); $i++)\n    $arr[$i] = $output[$i];\n    \n  return $arr;\n}`,\n      javascript: `function countingSort(arr) {\n  const max = Math.max(...arr);\n  const min = Math.min(...arr);\n  const range = max - min + 1;\n  const count = new Array(range).fill(0);\n  const output = new Array(arr.length).fill(0);\n  \n  for (let i = 0; i < arr.length; i++)\n    count[arr[i] - min]++;\n    \n  for (let i = 1; i < count.length; i++)\n    count[i] += count[i - 1];\n    \n  for (let i = arr.length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n  \n  for (let i = 0; i < arr.length; i++)\n    arr[i] = output[i];\n}`,\n      csharp: `public void CountingSort(int[] arr) {\n  int max = arr.Max();\n  int min = arr.Min();\n  int range = max - min + 1;\n  int[] count = new int[range];\n  int[] output = new int[arr.Length];\n  \n  for (int i = 0; i < arr.Length; i++)\n    count[arr[i] - min]++;\n    \n  for (int i = 1; i < count.Length; i++)\n    count[i] += count[i - 1];\n    \n  for (int i = arr.Length - 1; i >= 0; i--) {\n    output[count[arr[i] - min] - 1] = arr[i];\n    count[arr[i] - min]--;\n  }\n  \n  Array.Copy(output, arr, arr.Length);\n}`\n    }\n  },\n  {\n    id: 'radix-sort',\n    name: 'Radix Sort',\n    description: 'A non-comparative sorting algorithm that sorts data with integer keys by grouping keys by the individual digits.',\n    complexity: 'Best: O(nk), Average: O(nk), Worst: O(nk)',\n    code: {\n      java: `public void radixSort(int[] arr) {\n  int max = Arrays.stream(arr).max().getAsInt();\n  for (int exp = 1; max/exp > 0; exp *= 10)\n    countSort(arr, exp);\n}\n\nprivate void countSort(int[] arr, int exp) {\n  int[] output = new int[arr.length];\n  int[] count = new int[10];\n  \n  for (int i = 0; i < arr.length; i++)\n    count[(arr[i]/exp) % 10]++;\n    \n  for (int i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n    \n  for (int i = arr.length - 1; i >= 0; i--) {\n    output[count[(arr[i]/exp) % 10] - 1] = arr[i];\n    count[(arr[i]/exp) % 10]--;\n  }\n  \n  System.arraycopy(output, 0, arr, 0, arr.length);\n}`,\n      python: `def counting_sort(arr, exp):\n  n = len(arr)\n  output = [0] * n\n  count = [0] * 10\n  \n  for i in range(n):\n    index = arr[i] // exp\n    count[index % 10] += 1\n    \n  for i in range(1, 10):\n    count[i] += count[i - 1]\n    \n  i = n - 1\n  while i >= 0:\n    index = arr[i] // exp\n    output[count[index % 10] - 1] = arr[i]\n    count[index % 10] -= 1\n    i -= 1\n    \n  for i in range(n):\n    arr[i] = output[i]\n\ndef radix_sort(arr):\n  max_val = max(arr)\n  exp = 1\n  while max_val // exp > 0:\n    counting_sort(arr, exp)\n    exp *= 10`,\n      php: `function countSort(&$arr, $exp) {\n  $n = count($arr);\n  $output = array_fill(0, $n, 0);\n  $count = array_fill(0, 10, 0);\n  \n  for ($i = 0; $i < $n; $i++)\n    $count[($arr[$i]/$exp) % 10]++;\n    \n  for ($i = 1; $i < 10; $i++)\n    $count[$i] += $count[$i - 1];\n    \n  for ($i = $n - 1; $i >= 0; $i--) {\n    $output[$count[($arr[$i]/$exp) % 10] - 1] = $arr[$i];\n    $count[($arr[$i]/$exp) % 10]--;\n  }\n  \n  for ($i = 0; $i < $n; $i++)\n    $arr[$i] = $output[$i];\n}\n\nfunction radixSort($arr) {\n  $max = max($arr);\n  for ($exp = 1; $max/$exp > 0; $exp *= 10)\n    countSort($arr, $exp);\n  return $arr;\n}`,\n      javascript: `function countSort(arr, exp) {\n  const n = arr.length;\n  const output = new Array(n).fill(0);\n  const count = new Array(10).fill(0);\n  \n  for (let i = 0; i < n; i++)\n    count[Math.floor(arr[i]/exp) % 10]++;\n    \n  for (let i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n    \n  for (let i = n - 1; i >= 0; i--) {\n    output[count[Math.floor(arr[i]/exp) % 10] - 1] = arr[i];\n    count[Math.floor(arr[i]/exp) % 10]--;\n  }\n  \n  for (let i = 0; i < n; i++)\n    arr[i] = output[i];\n}\n\nfunction radixSort(arr) {\n  const max = Math.max(...arr);\n  for (let exp = 1; Math.floor(max/exp) > 0; exp *= 10)\n    countSort(arr, exp);\n}`,\n      csharp: `private void CountSort(int[] arr, int exp) {\n  int n = arr.Length;\n  int[] output = new int[n];\n  int[] count = new int[10];\n  \n  for (int i = 0; i < n; i++)\n    count[(arr[i]/exp) % 10]++;\n    \n  for (int i = 1; i < 10; i++)\n    count[i] += count[i - 1];\n    \n  for (int i = n - 1; i >= 0; i--) {\n    output[count[(arr[i]/exp) % 10] - 1] = arr[i];\n    count[(arr[i]/exp) % 10]--;\n  }\n  \n  Array.Copy(output, arr, n);\n}\n\npublic void RadixSort(int[] arr) {\n  int max = arr.Max();\n  for (int exp = 1; max/exp > 0; exp *= 10)\n    CountSort(arr, exp);\n}`\n    }\n  },\n  {\n    id: 'bucket-sort',\n    name: 'Bucket Sort',\n    description: 'A sorting algorithm that works by distributing the elements of an array into a number of buckets.',\n    complexity: 'Best: O(n + k), Average: O(n + n²/k), Worst: O(n²)',\n    code: {\n      java: `public void bucketSort(float[] arr) {\n  int n = arr.length;\n  ArrayList<Float>[] buckets = new ArrayList[n];\n  \n  for (int i = 0; i < n; i++)\n    buckets[i] = new ArrayList<>();\n    \n  for (int i = 0; i < n; i++) {\n    int bucketIndex = (int) (n * arr[i]);\n    buckets[bucketIndex].add(arr[i]);\n  }\n  \n  for (int i = 0; i < n; i++)\n    Collections.sort(buckets[i]);\n    \n  int index = 0;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < buckets[i].size(); j++)\n      arr[index++] = buckets[i].get(j);\n}`,\n      python: `def bucket_sort(arr):\n  n = len(arr)\n  buckets = [[] for _ in range(n)]\n  \n  for num in arr:\n    bucket_index = int(n * num)\n    buckets[bucket_index].append(num)\n    \n  for bucket in buckets:\n    bucket.sort()\n    \n  index = 0\n  for bucket in buckets:\n    for num in bucket:\n      arr[index] = num\n      index += 1`,\n      php: `function bucketSort($arr) {\n  $n = count($arr);\n  $buckets = array_fill(0, $n, array());\n  \n  for ($i = 0; $i < $n; $i++) {\n    $bucketIndex = (int)($n * $arr[$i]);\n    $buckets[$bucketIndex][] = $arr[$i];\n  }\n  \n  for ($i = 0; $i < $n; $i++)\n    sort($buckets[$i]);\n    \n  $index = 0;\n  for ($i = 0; $i < $n; $i++)\n    for ($j = 0; $j < count($buckets[$i]); $j++)\n      $arr[$index++] = $buckets[$i][$j];\n      \n  return $arr;\n}`,\n      javascript: `function bucketSort(arr) {\n  const n = arr.length;\n  const buckets = Array.from({ length: n }, () => []);\n  \n  for (const num of arr) {\n    const bucketIndex = Math.floor(n * num);\n    buckets[bucketIndex].push(num);\n  }\n  \n  for (const bucket of buckets)\n    bucket.sort((a, b) => a - b);\n    \n  let index = 0;\n  for (const bucket of buckets)\n    for (const num of bucket)\n      arr[index++] = num;\n}`,\n      csharp: `public void BucketSort(float[] arr) {\n  int n = arr.Length;\n  List<float>[] buckets = new List<float>[n];\n  \n  for (int i = 0; i < n; i++)\n    buckets[i] = new List<float>();\n    \n  for (int i = 0; i < n; i++) {\n    int bucketIndex = (int)(n * arr[i]);\n    buckets[bucketIndex].Add(arr[i]);\n  }\n  \n  for (int i = 0; i < n; i++)\n    buckets[i].Sort();\n    \n  int index = 0;\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < buckets[i].Count; j++)\n      arr[index++] = buckets[i][j];\n}`\n    }\n  },\n  {\n    id: 'cocktail-sort',\n    name: 'Cocktail Sort',\n    description: 'A variation of bubble sort that sorts in both directions alternatively.',\n    complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void cocktailSort(int[] arr) {\n  boolean swapped = true;\n  int start = 0;\n  int end = arr.length;\n  \n  while (swapped) {\n    swapped = false;\n    for (int i = start; i < end - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    \n    if (!swapped) break;\n    \n    swapped = false;\n    end--;\n    \n    for (int i = end - 1; i >= start; i--) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    start++;\n  }\n}`,\n      python: `def cocktail_sort(arr):\n  n = len(arr)\n  swapped = True\n  start = 0\n  end = n - 1\n  \n  while swapped:\n    swapped = False\n    for i in range(start, end):\n      if arr[i] > arr[i + 1]:\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n        swapped = True\n        \n    if not swapped:\n      break\n      \n    swapped = False\n    end -= 1\n    \n    for i in range(end - 1, start - 1, -1):\n      if arr[i] > arr[i + 1]:\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n        swapped = True\n        \n    start += 1`,\n      php: `function cocktailSort($arr) {\n  $n = count($arr);\n  $swapped = true;\n  $start = 0;\n  $end = $n - 1;\n  \n  while ($swapped) {\n    $swapped = false;\n    for ($i = $start; $i < $end; $i++) {\n      if ($arr[$i] > $arr[$i + 1]) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$i + 1];\n        $arr[$i + 1] = $temp;\n        $swapped = true;\n      }\n    }\n    \n    if (!$swapped) break;\n    \n    $swapped = false;\n    $end--;\n    \n    for ($i = $end - 1; $i >= $start; $i--) {\n      if ($arr[$i] > $arr[$i + 1]) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$i + 1];\n        $arr[$i + 1] = $temp;\n        $swapped = true;\n      }\n    }\n    $start++;\n  }\n  return $arr;\n}`,\n      javascript: `function cocktailSort(arr) {\n  let swapped = true;\n  let start = 0;\n  let end = arr.length;\n  \n  while (swapped) {\n    swapped = false;\n    for (let i = start; i < end - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n        swapped = true;\n      }\n    }\n    \n    if (!swapped) break;\n    \n    swapped = false;\n    end--;\n    \n    for (let i = end - 1; i >= start; i--) {\n      if (arr[i] > arr[i + 1]) {\n        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];\n        swapped = true;\n      }\n    }\n    start++;\n  }\n}`,\n      csharp: `public void CocktailSort(int[] arr) {\n  bool swapped = true;\n  int start = 0;\n  int end = arr.Length;\n  \n  while (swapped) {\n    swapped = false;\n    for (int i = start; i < end - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    \n    if (!swapped) break;\n    \n    swapped = false;\n    end--;\n    \n    for (int i = end - 1; i >= start; i--) {\n      if (arr[i] > arr[i + 1]) {\n        int temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n    start++;\n  }\n}`\n    }\n  },\n  {\n    id: 'gnome-sort',\n    name: 'Gnome Sort',\n    description: 'A sorting algorithm similar to insertion sort, but moving elements to their proper place by a series of swaps.',\n    complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void gnomeSort(int[] arr) {\n  int index = 0;\n  while (index < arr.length) {\n    if (index == 0)\n      index++;\n    if (arr[index] >= arr[index - 1])\n      index++;\n    else {\n      int temp = arr[index];\n      arr[index] = arr[index - 1];\n      arr[index - 1] = temp;\n      index--;\n    }\n  }\n}`,\n      python: `def gnome_sort(arr):\n  index = 0\n  while index < len(arr):\n    if index == 0:\n      index += 1\n    if arr[index] >= arr[index - 1]:\n      index += 1\n    else:\n      arr[index], arr[index - 1] = arr[index - 1], arr[index]\n      index -= 1`,\n      php: `function gnomeSort($arr) {\n  $index = 0;\n  while ($index < count($arr)) {\n    if ($index == 0)\n      $index++;\n    if ($arr[$index] >= $arr[$index - 1])\n      $index++;\n    else {\n      $temp = $arr[$index];\n      $arr[$index] = $arr[$index - 1];\n      $arr[$index - 1] = $temp;\n      $index--;\n    }\n  }\n  return $arr;\n}`,\n      javascript: `function gnomeSort(arr) {\n  let index = 0;\n  while (index < arr.length) {\n    if (index == 0)\n      index++;\n    if (arr[index] >= arr[index - 1])\n      index++;\n    else {\n      [arr[index], arr[index - 1]] = [arr[index - 1], arr[index]];\n      index--;\n    }\n  }\n}`,\n      csharp: `public void GnomeSort(int[] arr) {\n  int index = 0;\n  while (index < arr.Length) {\n    if (index == 0)\n      index++;\n    if (arr[index] >= arr[index - 1])\n      index++;\n    else {\n      int temp = arr[index];\n      arr[index] = arr[index - 1];\n      arr[index - 1] = temp;\n      index--;\n    }\n  }\n}`\n    }\n  },\n  {\n    id: 'comb-sort',\n    name: 'Comb Sort',\n    description: 'An improvement over bubble sort that uses a gap sequence to eliminate turtles.',\n    complexity: 'Best: O(n log n), Average: O(n²/2^p), Worst: O(n²)',\n    code: {\n      java: `public void combSort(int[] arr) {\n  int n = arr.length;\n  int gap = n;\n  boolean swapped = true;\n  \n  while (gap != 1 || swapped) {\n    gap = getNextGap(gap);\n    swapped = false;\n    \n    for (int i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        int temp = arr[i];\n        arr[i] = arr[i + gap];\n        arr[i + gap] = temp;\n        swapped = true;\n      }\n    }\n  }\n}\n\nprivate int getNextGap(int gap) {\n  gap = (gap * 10) / 13;\n  return Math.max(1, gap);\n}`,\n      python: `def get_next_gap(gap):\n  gap = (gap * 10) // 13\n  return max(1, gap)\n\ndef comb_sort(arr):\n  n = len(arr)\n  gap = n\n  swapped = True\n  \n  while gap != 1 or swapped:\n    gap = get_next_gap(gap)\n    swapped = False\n    \n    for i in range(n - gap):\n      if arr[i] > arr[i + gap]:\n        arr[i], arr[i + gap] = arr[i + gap], arr[i]\n        swapped = True`,\n      php: `function getNextGap($gap) {\n  $gap = ($gap * 10) / 13;\n  return max(1, $gap);\n}\n\nfunction combSort($arr) {\n  $n = count($arr);\n  $gap = $n;\n  $swapped = true;\n  \n  while ($gap != 1 || $swapped) {\n    $gap = getNextGap($gap);\n    $swapped = false;\n    \n    for ($i = 0; $i < $n - $gap; $i++) {\n      if ($arr[$i] > $arr[$i + $gap]) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$i + $gap];\n        $arr[$i + $gap] = $temp;\n        $swapped = true;\n      }\n    }\n  }\n  return $arr;\n}`,\n      javascript: `function getNextGap(gap) {\n  gap = (gap * 10) / 13;\n  return Math.max(1, Math.floor(gap));\n}\n\nfunction combSort(arr) {\n  let n = arr.length;\n  let gap = n;\n  let swapped = true;\n  \n  while (gap != 1 || swapped) {\n    gap = getNextGap(gap);\n    swapped = false;\n    \n    for (let i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        [arr[i], arr[i + gap]] = [arr[i + gap], arr[i]];\n        swapped = true;\n      }\n    }\n  }\n}`,\n      csharp: `private int GetNextGap(int gap) {\n  gap = (gap * 10) / 13;\n  return Math.Max(1, gap);\n}\n\npublic void CombSort(int[] arr) {\n  int n = arr.Length;\n  int gap = n;\n  bool swapped = true;\n  \n  while (gap != 1 || swapped) {\n    gap = GetNextGap(gap);\n    swapped = false;\n    \n    for (int i = 0; i < n - gap; i++) {\n      if (arr[i] > arr[i + gap]) {\n        int temp = arr[i];\n        arr[i] = arr[i + gap];\n        arr[i + gap] = temp;\n        swapped = true;\n      }\n    }\n  }\n}`\n    }\n  },\n  {\n    id: 'cycle-sort',\n    name: 'Cycle Sort',\n    description: 'An in-place sorting algorithm that minimizes the number of writes to memory.',\n    complexity: 'Best: O(n²), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void cycleSort(int[] arr) {\n  int n = arr.length;\n  \n  for (int cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n    int item = arr[cycleStart];\n    int pos = cycleStart;\n    \n    for (int i = cycleStart + 1; i < n; i++)\n      if (arr[i] < item)\n        pos++;\n        \n    if (pos == cycleStart)\n      continue;\n      \n    while (item == arr[pos])\n      pos++;\n      \n    int temp = arr[pos];\n    arr[pos] = item;\n    item = temp;\n    \n    while (pos != cycleStart) {\n      pos = cycleStart;\n      for (int i = cycleStart + 1; i < n; i++)\n        if (arr[i] < item)\n          pos++;\n          \n      while (item == arr[pos])\n        pos++;\n        \n      temp = arr[pos];\n      arr[pos] = item;\n      item = temp;\n    }\n  }\n}`,\n      python: `def cycle_sort(arr):\n  n = len(arr)\n  \n  for cycle_start in range(n - 1):\n    item = arr[cycle_start]\n    pos = cycle_start\n    \n    for i in range(cycle_start + 1, n):\n      if arr[i] < item:\n        pos += 1\n        \n    if pos == cycle_start:\n      continue\n      \n    while item == arr[pos]:\n      pos += 1\n      \n    arr[pos], item = item, arr[pos]\n    \n    while pos != cycle_start:\n      pos = cycle_start\n      for i in range(cycle_start + 1, n):\n        if arr[i] < item:\n          pos += 1\n          \n      while item == arr[pos]:\n        pos += 1\n        \n      arr[pos], item = item, arr[pos]`,\n      php: `function cycleSort($arr) {\n  $n = count($arr);\n  \n  for ($cycleStart = 0; $cycleStart < $n - 1; $cycleStart++) {\n    $item = $arr[$cycleStart];\n    $pos = $cycleStart;\n    \n    for ($i = $cycleStart + 1; $i < $n; $i++)\n      if ($arr[$i] < $item)\n        $pos++;\n        \n    if ($pos == $cycleStart)\n      continue;\n      \n    while ($item == $arr[$pos])\n      $pos++;\n      \n    $temp = $arr[$pos];\n    $arr[$pos] = $item;\n    $item = $temp;\n    \n    while ($pos != $cycleStart) {\n      $pos = $cycleStart;\n      for ($i = $cycleStart + 1; $i < $n; $i++)\n        if ($arr[$i] < $item)\n          $pos++;\n          \n      while ($item == $arr[$pos])\n        $pos++;\n        \n      $temp = $arr[$pos];\n      $arr[$pos] = $item;\n      $item = $temp;\n    }\n  }\n  return $arr;\n}`,\n      javascript: `function cycleSort(arr) {\n  const n = arr.length;\n  \n  for (let cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n    let item = arr[cycleStart];\n    let pos = cycleStart;\n    \n    for (let i = cycleStart + 1; i < n; i++)\n      if (arr[i] < item)\n        pos++;\n        \n    if (pos == cycleStart)\n      continue;\n      \n    while (item == arr[pos])\n      pos++;\n      \n    [arr[pos], item] = [item, arr[pos]];\n    \n    while (pos != cycleStart) {\n      pos = cycleStart;\n      for (let i = cycleStart + 1; i < n; i++)\n        if (arr[i] < item)\n          pos++;\n          \n      while (item == arr[pos])\n        pos++;\n        \n      [arr[pos], item] = [item, arr[pos]];\n    }\n  }\n}`,\n      csharp: `public void CycleSort(int[] arr) {\n  int n = arr.Length;\n  \n  for (int cycleStart = 0; cycleStart < n - 1; cycleStart++) {\n    int item = arr[cycleStart];\n    int pos = cycleStart;\n    \n    for (int i = cycleStart + 1; i < n; i++)\n      if (arr[i] < item)\n        pos++;\n        \n    if (pos == cycleStart)\n      continue;\n      \n    while (item == arr[pos])\n      pos++;\n      \n    int temp = arr[pos];\n    arr[pos] = item;\n    item = temp;\n    \n    while (pos != cycleStart) {\n      pos = cycleStart;\n      for (int i = cycleStart + 1; i < n; i++)\n        if (arr[i] < item)\n          pos++;\n          \n      while (item == arr[pos])\n        pos++;\n        \n      temp = arr[pos];\n      arr[pos] = item;\n      item = temp;\n    }\n  }\n}`\n    }\n  },\n  {\n    id: 'pancake-sort',\n    name: 'Pancake Sort',\n    description: 'A sorting algorithm that sorts an array by repeatedly flipping portions of the array.',\n    complexity: 'Best: O(n), Average: O(n²), Worst: O(n²)',\n    code: {\n      java: `public void pancakeSort(int[] arr) {\n  for (int currSize = arr.length; currSize > 1; currSize--) {\n    int mi = findMax(arr, currSize);\n    if (mi != currSize - 1) {\n      flip(arr, mi);\n      flip(arr, currSize - 1);\n    }\n  }\n}\n\nprivate int findMax(int[] arr, int n) {\n  int mi = 0;\n  for (int i = 0; i < n; i++)\n    if (arr[i] > arr[mi])\n      mi = i;\n  return mi;\n}\n\nprivate void flip(int[] arr, int i) {\n  int start = 0;\n  while (start < i) {\n    int temp = arr[start];\n    arr[start] = arr[i];\n    arr[i] = temp;\n    start++;\n    i--;\n  }\n}`,\n      python: `def find_max(arr, n):\n  mi = 0\n  for i in range(n):\n    if arr[i] > arr[mi]:\n      mi = i\n  return mi\n\ndef flip(arr, i):\n  start = 0\n  while start < i:\n    arr[start], arr[i] = arr[i], arr[start]\n    start += 1\n    i -= 1\n\ndef pancake_sort(arr):\n  curr_size = len(arr)\n  while curr_size > 1:\n    mi = find_max(arr, curr_size)\n    if mi != curr_size - 1:\n      flip(arr, mi)\n      flip(arr, curr_size - 1)\n    curr_size -= 1`,\n      php: `function findMax($arr, $n) {\n  $mi = 0;\n  for ($i = 0; $i < $n; $i++)\n    if ($arr[$i] > $arr[$mi])\n      $mi = $i;\n  return $mi;\n}\n\nfunction flip(&$arr, $i) {\n  $start = 0;\n  while ($start < $i) {\n    $temp = $arr[$start];\n    $arr[$start] = $arr[$i];\n    $arr[$i] = $temp;\n    $start++;\n    $i--;\n  }\n}\n\nfunction pancakeSort($arr) {\n  $curr_size = count($arr);\n  while ($curr_size > 1) {\n    $mi = findMax($arr, $curr_size);\n    if ($mi != $curr_size - 1) {\n      flip($arr, $mi);\n      flip($arr, $curr_size - 1);\n    }\n    $curr_size--;\n  }\n  return $arr;\n}`,\n      javascript: `function findMax(arr, n) {\n  let mi = 0;\n  for (let i = 0; i < n; i++)\n    if (arr[i] > arr[mi])\n      mi = i;\n  return mi;\n}\n\nfunction flip(arr, i) {\n  let start = 0;\n  while (start < i) {\n    [arr[start], arr[i]] = [arr[i], arr[start]];\n    start++;\n    i--;\n  }\n}\n\nfunction pancakeSort(arr) {\n  let currSize = arr.length;\n  while (currSize > 1) {\n    const mi = findMax(arr, currSize);\n    if (mi != currSize - 1) {\n      flip(arr, mi);\n      flip(arr, currSize - 1);\n    }\n    currSize--;\n  }\n}`,\n      csharp: `private int FindMax(int[] arr, int n) {\n  int mi = 0;\n  for (int i = 0; i < n; i++)\n    if (arr[i] > arr[mi])\n      mi = i;\n  return mi;\n}\n\nprivate void Flip(int[] arr, int i) {\n  int start = 0;\n  while (start < i) {\n    int temp = arr[start];\n    arr[start] = arr[i];\n    arr[i] = temp;\n    start++;\n    i--;\n  }\n}\n\npublic void PancakeSort(int[] arr) {\n  int currSize = arr.Length;\n  while (currSize > 1) {\n    int mi = FindMax(arr, currSize);\n    if (mi != currSize - 1) {\n      Flip(arr, mi);\n      Flip(arr, currSize - 1);\n    }\n    currSize--;\n  }\n}`\n    }\n  },\n  {\n    id: 'bogo-sort',\n    name: 'Bogo Sort',\n    description: 'A highly inefficient sorting algorithm that randomly shuffles the array until it is sorted. This algorithm is mainly used for educational purposes to demonstrate the worst-case scenario of sorting algorithms.',\n    complexity: 'Best: O(1), Average: O(n * n!), Worst: O(∞)',\n    code: {\n      java: `public void bogoSort(int[] arr) {\n  while (!isSorted(arr)) {\n    shuffle(arr);\n  }\n}\n\nprivate boolean isSorted(int[] arr) {\n  for (int i = 0; i < arr.length - 1; i++) {\n    if (arr[i] > arr[i + 1]) return false;\n  }\n  return true;\n}\n\nprivate void shuffle(int[] arr) {\n  Random rand = new Random();\n  for (int i = arr.length - 1; i > 0; i--) {\n    int j = rand.nextInt(i + 1);\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n}`,\n      python: `def bogo_sort(arr):\n  while not is_sorted(arr):\n    shuffle(arr)\n\ndef is_sorted(arr):\n  for i in range(len(arr) - 1):\n    if arr[i] > arr[i + 1]:\n      return False\n  return True\n\ndef shuffle(arr):\n  import random\n  for i in range(len(arr) - 1, 0, -1):\n    j = random.randint(0, i)\n    arr[i], arr[j] = arr[j], arr[i]`,\n      php: `function bogoSort(&$arr) {\n  while (!isSorted($arr)) {\n    shuffle($arr);\n  }\n}\n\nfunction isSorted($arr) {\n  for ($i = 0; $i < count($arr) - 1; $i++) {\n    if ($arr[$i] > $arr[$i + 1]) return false;\n  }\n  return true;\n}\n\nfunction shuffle(&$arr) {\n  for ($i = count($arr) - 1; $i > 0; $i--) {\n    $j = rand(0, $i);\n    $temp = $arr[$i];\n    $arr[$i] = $arr[$j];\n    $arr[$j] = $temp;\n  }\n}`,\n      javascript: `function bogoSort(arr) {\n  while (!isSorted(arr)) {\n    shuffle(arr);\n  }\n}\n\nfunction isSorted(arr) {\n  for (let i = 0; i < arr.length - 1; i++) {\n    if (arr[i] > arr[i + 1]) return false;\n  }\n  return true;\n}\n\nfunction shuffle(arr) {\n  for (let i = arr.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [arr[i], arr[j]] = [arr[j], arr[i]];\n  }\n}`,\n      csharp: `public void BogoSort(int[] arr)\n{\n    while (!IsSorted(arr))\n    {\n        Shuffle(arr);\n    }\n}\n\nprivate bool IsSorted(int[] arr)\n{\n    for (int i = 0; i < arr.Length - 1; i++)\n    {\n        if (arr[i] > arr[i + 1]) return false;\n    }\n    return true;\n}\n\nprivate void Shuffle(int[] arr)\n{\n    Random rand = new Random();\n    for (int i = arr.Length - 1; i > 0; i--)\n    {\n        int j = rand.Next(i + 1);\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}`\n    }\n  }\n]; "],"mappings":"AAcA,OAAO,MAAMA,UAAuB,GAAG,CACrC;EACEC,EAAE,EAAE,aAAa;EACjBC,IAAI,EAAE,aAAa;EACnBC,WAAW,EAAE,mIAAmI;EAChJC,UAAU,EAAE,0CAA0C;EACtDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA,4CAA4C;IACtCC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,YAAY;EAChBC,IAAI,EAAE,YAAY;EAClBC,WAAW,EAAE,qHAAqH;EAClIC,UAAU,EAAE,qDAAqD;EACjEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;IACPC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,YAAY;EAChBC,IAAI,EAAE,YAAY;EAClBC,WAAW,EAAE,sJAAsJ;EACnKC,UAAU,EAAE,0DAA0D;EACtEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;IACPC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,gBAAgB;EACpBC,IAAI,EAAE,gBAAgB;EACtBC,WAAW,EAAE,mFAAmF;EAChGC,UAAU,EAAE,0CAA0C;EACtDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;IACfC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,gBAAgB;EACpBC,IAAI,EAAE,gBAAgB;EACtBC,WAAW,EAAE,oHAAoH;EACjIC,UAAU,EAAE,2CAA2C;EACvDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;IAC1CC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,WAAW;EACfC,IAAI,EAAE,WAAW;EACjBC,WAAW,EAAE,+FAA+F;EAC5GC,UAAU,EAAE,0DAA0D;EACtEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;IACjBC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,YAAY;EAChBC,IAAI,EAAE,YAAY;EAClBC,WAAW,EAAE,yFAAyF;EACtGC,UAAU,EAAE,sDAAsD;EAClEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;IACRC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,eAAe;EACnBC,IAAI,EAAE,eAAe;EACrBC,WAAW,EAAE,8FAA8F;EAC3GC,UAAU,EAAE,oDAAoD;EAChEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;IACjBC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,YAAY;EAChBC,IAAI,EAAE,YAAY;EAClBC,WAAW,EAAE,kHAAkH;EAC/HC,UAAU,EAAE,2CAA2C;EACvDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;IACRC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,aAAa;EACjBC,IAAI,EAAE,aAAa;EACnBC,WAAW,EAAE,mGAAmG;EAChHC,UAAU,EAAE,oDAAoD;EAChEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;IACXC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,eAAe;EACnBC,IAAI,EAAE,eAAe;EACrBC,WAAW,EAAE,yEAAyE;EACtFC,UAAU,EAAE,0CAA0C;EACtDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;IACTC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,YAAY;EAChBC,IAAI,EAAE,YAAY;EAClBC,WAAW,EAAE,gHAAgH;EAC7HC,UAAU,EAAE,0CAA0C;EACtDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;IACXC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,WAAW;EACfC,IAAI,EAAE,WAAW;EACjBC,WAAW,EAAE,gFAAgF;EAC7FC,UAAU,EAAE,oDAAoD;EAChEC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;IACjBC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,YAAY;EAChBC,IAAI,EAAE,YAAY;EAClBC,WAAW,EAAE,8EAA8E;EAC3FC,UAAU,EAAE,2CAA2C;EACvDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;IAChCC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,cAAc;EAClBC,IAAI,EAAE,cAAc;EACpBC,WAAW,EAAE,uFAAuF;EACpGC,UAAU,EAAE,0CAA0C;EACtDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;IACbC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,EACD;EACET,EAAE,EAAE,WAAW;EACfC,IAAI,EAAE,WAAW;EACjBC,WAAW,EAAE,kNAAkN;EAC/NC,UAAU,EAAE,6CAA6C;EACzDC,IAAI,EAAE;IACJC,IAAI,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;IAC9BC,GAAG,EAAE;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,UAAU,EAAE;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;IACIC,MAAM,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI;AACF,CAAC,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}